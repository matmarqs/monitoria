class Group:    # structure definida como uma lista de 'Element' e o nome do grupo
    def __init__(self, elements, name):
        self.elements = elements
        self.order = len(elements)
        self.name = name
        self.E = elements[0]    # identity element
    def find(self, perm):  # procura o elemento correspondente a uma permutação dada
        for g in self.elements:
            if perm == g.perm:
                return g
        return None
    def printtable(self):  # método que printa a tabela de multiplicação em LaTeX
        elem = self.elements
        group_name = self.name
        order = self.order
        def tabular_string(n):
            s = "|c|"
            while n > 0:
                s = s+"c " if n > 1 else s+"c |"
                n -= 1
            return s
        print(r'\begin{tabular} { %s }' % tabular_string(order)) # tabular do LaTeX
        print(r'\hline')    # linha horizontal
        print(group_name+' ', end='')
        for j in range(order): # printa a primeira linha com os elementos
            if j < order-1:
                print(f'& {elem[j].eqname} ', end='')
            else:
                print(f'& {elem[j].eqname} \\\\')
        print(r'\hline')
        for i in range(order):
            print(f'{elem[i].eqname} & ', end='')  # printa a primeira coluna
            for j in range(order):
                res = self.find(elem[i].perm * elem[j].perm)  # multiplica elementos
                if j < order-1:
                    print(f'{res.eqname} & ', end='')
                else:
                    print(f'{res.eqname} \\\\')
        print(r'\hline')
        print(r'\end{tabular}')
# https://math.stackexchange.com/questions/1758649/
# an-algorithm-to-find-a-subgroup-generated-by-a-subset-of-a-finite-group
    def gen_subgroup(self, subset):
        queue = [self.E]    # auxiliary queue
        H = set()   # subgroup generated by subset
        while queue:
            x = queue.pop()
            if x in H:
                continue
            H.add(x)
            for s in subset:
                queue.append(self.find(x.perm * s.perm))
        return H
    def is_subgroup(self, subset):
        return self.gen_subgroup(subset) == subset
    def get_subgroups(self):
        subgroups = []
        subsets = [subset for subset in powerset(self.elements) if subset]
        for subset in subsets:
            if len(subset) != 0:
                if self.order % len(subset) == 0:
                    if self.is_subgroup(subset):
                        subgroups.append(subset)
        return subgroups

class Element:  # Permutacao e o nome
    def __init__(self, perm, eqname):
        self.perm = perm
        self.name = eqname[1:-1]  # remove '\$\$' from latex equation
        self.eqname = eqname
    #### DEBUG #####
    def show(self):
        self.perm.show()

class Perm:
    def __init__(self, L):  # inicialização a partir de uma lista
        self.n = len(L)     # tamanho da lista
        self.list = [i-1 for i in L]  # subtrair 1 para indexar a partir do zero
    def __eq__(self, other):
        return self.list == other.list  # são iguais se as listas são iguais
    def __mul__(self, other):  # multiplicação de duas permutações
        return Perm([self.list[i]+1 for i in other.list])  # composição
    def find(self, j):  # método auxiliar para achar a posição de um número na lista
        for i in range(self.n):
            if self.list[i] == j:
                return i
    def inv(self):  # calcula a inversa de uma permutação
        return Perm([self.find(j)+1 for j in range(self.n)])
    #### DEBUG #####
    def show(self):
        print('( ', end='')
        for i in range(self.n):
            print(f'{i+1} ', end='')
        print(')\n( ', end='')
        for i in self.list:
            print(f'{i+1} ', end='')
        print(')\n')

def ident(n):   # elemento identidade
    return Perm([i for i in range(1, n+1)])

def generate_D3h():
    E = Element(ident(8), r'$E$')
    C3 = Element(Perm([3,4,5,6,1,2,7,8]), r'$C_3$')
    C32 = Element(C3.perm.inv(), r'$C_3^2$')                            # $C_3^{-1}$
    Sigma_h = Element(Perm([2,1,4,3,6,5,8,7]), r'$\sigma_h$')
    C21 = Element(Perm([2,1,6,5,4,3,8,7]), r'$C_2^{(1)}$')
    C22 = Element(Perm([6,5,4,3,2,1,8,7]), r'$C_2^{(2)}$')
    C23 = Element(Perm([4,3,2,1,6,5,8,7]), r'$C_2^{(3)}$')
    S3 = Element(C3.perm * Sigma_h.perm, r'$S_3$')                      # $C_3 \sigma_h$
    S32 = Element(C32.perm * Sigma_h.perm, r'$S_3^2$')                  # $C_3^2 \sigma_h$
    Sigma_v1 = Element(C21.perm * Sigma_h.perm, r'$\sigma_v^{(1)}$')    # $C_2^{(1)} \sigma_h$
    Sigma_v2 = Element(C22.perm * Sigma_h.perm, r'$\sigma_v^{(2)}$')    # $C_2^{(2)} \sigma_h$
    Sigma_v3 = Element(C23.perm * Sigma_h.perm, r'$\sigma_v^{(3)}$')    # $C_2^{(3)} \sigma_h$
    D3h = Group([E, C3, C32, C21, C22, C23, Sigma_v1,
                 Sigma_v2, Sigma_v3, Sigma_h, S3, S32], r'$D_{3h}$')
    return D3h

def generate_D3d():
    E = Element(ident(8), r'$E$')
    C3 = Element(Perm([2,3,1,5,6,4,7,8]), r'$C_3$')
    C32 = Element(C3.perm.inv(), r'$C_3^2$')                    # $C_3^{-1}$
    C21 = Element(Perm([6,5,4,3,2,1,8,7]), r'$C_2^{(1)}$')
    C22 = Element(Perm([5,4,6,2,1,3,8,7]), r'$C_2^{(2)}$')
    C23 = Element(Perm([4,6,5,1,3,2,8,7]), r'$C_2^{(3)}$')
    I = Element(Perm([6,4,5,2,3,1,8,7]), r'$i$')
    S6 = Element(C3.perm * I.perm, r'$S_6$')                    # $C_3 i$
    S65 = Element(C32.perm * I.perm, r'$S_6^5$')                # $C_3^2 i$
    Sigma_d1 = Element(C21.perm * I.perm, r'$\sigma_d^{(1)}$')  # $C_2^{(1)} i$
    Sigma_d2 = Element(C22.perm * I.perm, r'$\sigma_d^{(2)}$')  # $C_2^{(2)} i$
    Sigma_d3 = Element(C23.perm * I.perm, r'$\sigma_d^{(3)}$')  # $C_2^{(3)} i$
    D3d = Group([E, C3, C32, C21, C22, C23,
                 Sigma_d1, Sigma_d2, Sigma_d3, I, S6, S65], r'$D_{3d}$')
    return D3d

def conjugacy_classes(group):
    classes = set()     # conjunto de classes
    for g in group.elements:
        g_class = set() # classe: conjunto de elementos
        for A in group.elements:
            g_class.add(group.find(A.perm.inv() * g.perm * A.perm)) # $A G A^{-1}$
        g_class = frozenset(g_class)  # frozenset para criar conjunto de conjuntos
        classes.add(g_class)
    return classes

def print_SetofElements(S):
    string = r"\{ "
    for g in S:
        string += "%s, " % g.name
    string = string[:-2] + r" \}"   # delete last two characters ", " and append " \}"
    print(string)

# https://github.com/priyanshupant/group-theory-python/blob/main/GROUP.py
def powerset(input_list):
    powerset_list = []
    n = len(input_list)
    for i in range(2 ** n):
        subset = set([input_list[j] for j in range(n) if (i >> j) & 1])
        powerset_list.append(subset)
    return powerset_list

def main():
    group = generate_D3d()
    #group = generate_D3h()
    print("MULTIPLICATION TABLE")
    group.printtable()
    print()

    classes = conjugacy_classes(group)
    print("CONJUGACY CLASSES")
    for cl in classes:
        print_SetofElements(cl)
    print()

    subgroups = group.get_subgroups()
    print("SUBGROUPS")
    for H in subgroups:
        print_SetofElements(H)
    print()

if __name__ == '__main__':
    main()
